SOLID PRINCIPLES

 ➡️ SRP. Single Responsibility Principle
    A module should have one, and only one, reason to change.

    A module should be responsible to one, and only one, actor.

 ➡️ OCP. Open Closed Principle
    A software artifact should be open for extension but closed for modification.

    We should not have to rewrite an existing class for implementing new features.

 ➡️ Liskov Substitution Principle
    If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,
    the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.

    Let f(x) be a property provable about objects x of type T. Then f(y) should be true for objects y of type S where S is a subtype of T.

    This means that every subclass or derived class should be substitutable for their base or parent class.

 ➡️ Interface Segregation Principle
    Clients should not be forced to depend upon interfaces that they do not use.
    Interfaces should not force classes to implement features that are of no interest to them.

    Large interfaces should be divided into small ones.

 ➡️ Dependency Inversion Principle
     High-level modules should not depend on low-level modules. Both should depend on abstractions.
     Abstractions should not depend on details. Details should depend on abstractions.

    Components should depend on anything concrete, only depend on abstractions.